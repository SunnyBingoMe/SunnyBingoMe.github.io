<!DOCTYPE html>
<!--[if IE 7]>
<html class="ie ie7" lang="en-US">
<![endif]--><!--[if IE 8]>
<html class="ie ie8" lang="en-US">
<![endif]--><!--[if !(IE 7) & !(IE 8)]><!--><html lang="en-US"><!--<![endif]--><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>19 | August | 2012 | Sunny Blog</title><link rel="profile" href="http://gmpg.org/xfn/11"><link rel="pingback" href="http://log.SunnyBoy.Me/xmlrpc.php"><!--[if lt IE 9]>
<script src="http://log.SunnyBoy.Me/wp-content/themes/twentytwelve/js/html5.js" type="text/javascript"></script>
<![endif]--><link rel="alternate" type="application/rss+xml" title="Sunny Blog &raquo; Feed" href="http://log.SunnyBoy.Me/feed/"><link rel="alternate" type="application/rss+xml" title="Sunny Blog &raquo; Comments Feed" href="http://log.SunnyBoy.Me/comments/feed/"><script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/log.SunnyBoy.Me\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.5.1"}};
			!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;if(!g||!g.fillText)return!1;switch(g.textBaseline="top",g.font="600 32px Arial",a){case"flag":return g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3;case"diversity":return g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,d=c[0]+","+c[1]+","+c[2]+","+c[3],g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e;case"simple":return g.fillText(h(55357,56835),0,0),0!==g.getImageData(16,16,1,1).data[0];case"unicode8":return g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0]}return!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g,h,i;for(i=Array("simple","flag","unicode8","diversity"),c.supports={everything:!0,everythingExceptFlag:!0},h=0;h<i.length;h++)c.supports[i[h]]=d(i[h]),c.supports.everything=c.supports.everything&&c.supports[i[h]],"flag"!==i[h]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[i[h]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script><style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style><link rel="stylesheet" id="twentytwelve-fonts-css" href="https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700&amp;subset=latin,latin-ext" type="text/css" media="all"><link rel="stylesheet" id="twentytwelve-style-css" href="http://log.SunnyBoy.Me/wp-content/themes/twentytwelve/style.css?ver=4.5.1" type="text/css" media="all"><!--[if lt IE 9]>
<link rel='stylesheet' id='twentytwelve-ie-css'  href='http://log.SunnyBoy.Me/wp-content/themes/twentytwelve/css/ie.css?ver=20121010' type='text/css' media='all' />
<![endif]--><script type="text/javascript" src="http://log.SunnyBoy.Me/wp-includes/js/jquery/jquery.js?ver=1.12.3"></script><script type="text/javascript" src="http://log.SunnyBoy.Me/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.0"></script><link rel="https://api.w.org/" href="http://log.SunnyBoy.Me/wp-json/"><link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://log.SunnyBoy.Me/xmlrpc.php?rsd"><link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://log.SunnyBoy.Me/wp-includes/wlwmanifest.xml"><meta name="generator" content="WordPress 4.5.1"><link rel="icon" href="http://log.SunnyBoy.Me/wp-content/uploads/2010/10/e7919ee585b8ae9809ae98193efbc9f.jpg" sizes="32x32"><link rel="icon" href="http://log.SunnyBoy.Me/wp-content/uploads/2010/10/e7919ee585b8ae9809ae98193efbc9f.jpg" sizes="192x192"><link rel="apple-touch-icon-precomposed" href="http://log.SunnyBoy.Me/wp-content/uploads/2010/10/e7919ee585b8ae9809ae98193efbc9f.jpg"><meta name="msapplication-TileImage" content="http://log.SunnyBoy.Me/wp-content/uploads/2010/10/e7919ee585b8ae9809ae98193efbc9f.jpg"></head><body class="archive date custom-font-enabled">
<div id="page" class="hfeed site">
	<header id="masthead" class="site-header" role="banner"><hgroup><h1 class="site-title"><a href="http://log.SunnyBoy.Me/" title="Sunny Blog" rel="home">Sunny Blog</a></h1>
			<h2 class="site-description">Mind And Hand Let There Be Light.</h2>
		</hgroup><nav id="site-navigation" class="main-navigation" role="navigation"><button class="menu-toggle">Menu</button>
			<a class="assistive-text" href="#content" title="Skip to content">Skip to content</a>
			<div class="nav-menu"><ul><li><a href="http://log.SunnyBoy.Me/">Home</a></li><li class="page_item page-item-402"><a href="http://log.SunnyBoy.Me/about_me/">About me &#20851;&#20110;&#25105;</a></li><li class="page_item page-item-1566"><a href="http://log.SunnyBoy.Me/media/">Media &#25105;&#30340;&#38899;&#20048;</a></li></ul></div>
		</nav><!-- #site-navigation --></header><!-- #masthead --><div id="main" class="wrapper">
	<section id="primary" class="site-content"><div id="content" role="main">

					<header class="archive-header"><h1 class="archive-title">Daily Archives: <span>2012/08/19</span></h1>
			</header><!-- .archive-header --><article id="post-13925" class="post-13925 post type-post status-publish format-standard hentry category-leading"><header class="entry-header"><h1 class="entry-title">
				<a href="http://log.SunnyBoy.Me/2012/08/19/13925/" rel="bookmark">Measuring TCP Congestion Windows [cwnd] [TCP Congestion Window Size] [measurement] [validation]</a>
			</h1>
										<div class="comments-link">
					<a href="http://log.SunnyBoy.Me/2012/08/19/13925/#respond"><span class="leave-reply">Leave a reply</span></a>				</div><!-- .comments-link -->
					</header><!-- .entry-header --><div class="entry-content">
			<p>By Ren&eacute; Pfeiffer</p>
<p>from:<a href="http://linuxgazette.net/136/pfeiffer.html">http://linuxgazette.net/136/pfeiffer.html</a></p>
<div></div>
<p><a href="http://linuxgazette.net/135/pfeiffer.html">Last month</a>, I introduced the various TCP congestion control algorithms your Linux kernel knows about. I also mentioned a method, using the kernel module&nbsp;<em>tcpprobe</em>, that allows for measuring the parameters of live TCP connections. Unfortunately, this module requires the presence of a debugging option in the kernel called&nbsp;<em>kprobes</em>. By enabling this, you can dynamically break into any kernel routine and collect debugging and performance information non-disruptively. This sounded good on first impression &ndash; but I decided that I don&rsquo;t wish to introduce kprobes on every machine I have; it&rsquo;s better to run less code on servers. Besides, it is not a good idea to run debugging code in kernels that shouldn&rsquo;t be used for debugging. I had to look for other mechanisms. After rediscovering the man pages on my GNU/Linux workstation at home, I found what I was looking for:&nbsp;<tt>getsockopt()</tt></p>
<h3>Ask the kernel, stupid!</h3>
<p>The Linux kernel has internal data structures that keep track of active TCP connections and their parameters. This is required, since most TCP connections have a long lifetime (long being tens of seconds, minutes, or even hours). The longer a connection lasts, the more changes on its path can happen. Other TCP connections might throttle the up- or downlink. The link might get disconnected, rerouted, or re-established. Packets might be lost or reordered. All these things have an impact on the TCP performance, and TCP usually reacts by changing its window size (among other things we won&rsquo;t look at right now.) Inside an application that owns a network socket with a live TCP connection, we can always request the current TCP parameters. The man pages of&nbsp;<tt>getsockopt()</tt>&nbsp;and&nbsp;<tt>tcp</tt>&nbsp;tell us how to do this &ndash; calling<tt>getsockopt()</tt>&nbsp;with the&nbsp;<tt>TCP_INFO</tt>&nbsp;option fills a memory structure with information described in&nbsp;<tt>struct tcp_info</tt>, which is defined in&nbsp;<tt>/usr/include/netinet/tcp.h</tt>. That&rsquo;s great &ndash; just what we&rsquo;re looking for! But how do we collect this information periodically while sending or receiving data?</p>
<h3>Making up a strategy</h3>
<p>The man pages refer to C structures and C function calls. I did a lot of C programming on my Amigas, so I decided to dust off my C skills. Since the kernel is written in C, and the GNU C Library has everything prepared, the way to get to our TCP parameters is straightforward.</p>
<ol><li>Prepare a TCP socket by calling&nbsp;<tt>socket()</tt></li>
<li>Bind to a (high, unprivileged) port by using&nbsp;<tt>bind()</tt></li>
<li>Put the port into listen state by utilising&nbsp;<tt>listen()</tt></li>
<li>Wait for an incoming connection by taking advantage of&nbsp;<tt>accept()</tt></li>
<li>Accept&nbsp;<em>n</em>&nbsp;bytes of data by means of&nbsp;<tt>recv()</tt>&nbsp;from data socket</li>
<li>Write out the TCP parameters to a file</li>
<li>Repeat until sender stops sending</li>
<li>Close data socket and return to listening for new connections</li>
</ol><p>Right. This sounds quite complete. By adjusting&nbsp;<em>n</em>, you can determine how many samples you get. It doesn&rsquo;t make sense to take multiple samples per TCP packet, which means that you should choose&nbsp;<em>n</em>above the Maximum Transfer Unit (MTU) on your connection path. Besides, if you send streams over the network that contain many megabytes (or even gigabytes), you might want to reduce the sample rate anyway.</p>
<p>We design our code so it can be used as a &ldquo;TCP sink&rdquo;. We don&rsquo;t want to store all the bytes we read from the network. We just need to fill a buffer up to a maximum of&nbsp;<em>n</em>&nbsp;bytes, look at the TCP parameters, and read the next&nbsp;<em>n</em>&nbsp;bytes. The only things we probably want to save are the parameters. Everything else is fed to the bit bucket.</p>
<h3>Walking through the steps</h3>
<p>Let&rsquo;s look at the steps of our strategy with more detail and some code. I am going to describe the task &ldquo;codewise&rdquo;, line by line. You will get a complete sample of the source to play with, at the end. First, we have to prepare the socket. Then, we have to bind it to a local address. Finally, we have to put the socket into the TCP LISTEN state.</p>
<pre>tcp_socket = socket( PF_INET, SOCK_STREAM, IPPROTO_TCP );
if ( tcp_socket == -1 ) {
/* Could not open socket. */
fprintf(stderr,"Could not open TCP socket: %s\n",strerror(errno));
exit(EXIT_FAILURE);
}
else {
/* Bind to any address on local machine */
server_address.sin_family = AF_INET;
server_address.sin_addr.s_addr = INADDR_ANY;
server_address.sin_port = htons(opt_port);
memset((void *)&amp;(server_address.sin_zero), '\0', 8);
status = bind( tcp_socket, (struct sockaddr *)&amp;server_address, sizeof(server_address) );
if ( status == 0 ) {
	/* We can now listen for incoming connections. We only allow a backlog of one
	 * connection
	 */
	status = listen( tcp_socket, 1 );
	if ( status != 0 ) {
		/* Cannot listen on socket. */
		fprintf(stderr,"Cannot listen on socket: %s\n",strerror(errno));
		exit(EXIT_FAILURE);
	}
}
else {
	/* Cannot bind to socket. */
	fprintf(stderr,"Cannot bind to socket: %s\n",strerror(errno));
	exit(EXIT_FAILURE);
}
}</pre>
<p>The call to&nbsp;<tt>socket()</tt>&nbsp;specifies that we&rsquo;d like to have an Internet (<tt>PF_INET</tt>) stream socket (<tt>SOCK_STREAM</tt>) that speaks TCP (<tt>IPPROTO_TCP</tt>). Provided the call succeeds, we prepare a data structure named<tt>server_address</tt>&nbsp;of the type&nbsp;<tt>struct sockaddr_in</tt>, which tells the kernel the address and the port to which we wish to bind the socket. We choose all available addresses by using&nbsp;<tt>INADDR_ANY</tt>, and we&rsquo;d like to bind on the port stored in the&nbsp;<tt>opt_port</tt>&nbsp;variable. (The full source handles the options; I left it out in this piece of code.) Be careful when doing network programming! Addresses and ports have a defined network and host byte order. This means that certain bytes might need to be swapped &ndash; or not &ndash; before putting them from the host side into network data structures and vice-versa. The function&nbsp;<tt>htons()</tt>converts the unsigned short integer TCP port from host byte order to network byte order. If you look up its man page, you will see that there are other functions for byte order conversion.</p>
<p>Now we can call the&nbsp;<tt>bind()</tt>&nbsp;function. We need to provide the TCP socket it should act on, and a pointer to a memory region of type&nbsp;<tt>struct sockaddr</tt>, along with the length of the memory region.<tt>server_address</tt>&nbsp;is the structure we filled for exactly these purposes. The function call may seem a bit complicated because of the pointer and the size of the structure &ndash; but as long as we make sure that the content of&nbsp;<tt>server_address</tt>&nbsp;is filled with correct values,&nbsp;<tt>bind()</tt>&nbsp;won&rsquo;t choke on it.</p>
<p>If the binding succeeds, we can put the socket into the listening state. This is done by a simple call to the&nbsp;<tt>listen()</tt>&nbsp;function. When listening for connections, you can tell the kernel how many connections it should keep in the queue for processing. As of kernel 2.2, this queue consists of completely established sockets waiting to be accepted. Since we don&rsquo;t need to deal with performance issues and multiple connections, we choose 1; we&rsquo;ll let other people worry about the design of a high-performance and multi-threaded TCP sink. After these three steps, our code is ready to accept and process data streams.</p>
<pre>client_length = sizeof(client_address);
tcp_work_socket = accept( tcp_socket, (struct sockaddr *)&amp;client_address, &amp;client_length );</pre>
<p>The call to&nbsp;<tt>accept()</tt>&nbsp;makes our code wait until a connection is received.&nbsp;<tt>client_address</tt>&nbsp;is of the same type as&nbsp;<tt>server_address</tt>&nbsp;was, earlier. It is a storage space for the address of the client that is talking to us.&nbsp;<tt>accept()</tt>&nbsp;fills out the details as soon as a client connects. In addition, the function returns an identifier of the socket that holds the conversation with our client. Keep in mind that our listening socket will always listen for incoming connections! Every connection we accept creates a new socket; that&rsquo;s why we use the variable&nbsp;<tt>tcp_work_socket</tt>&nbsp;for this. All we need to do now is to read incoming data. (We could also write &ldquo;to the other side&rdquo; and test bidirectional data flow, if we wanted to.)</p>
<p>Our little strategy above missed (or implied, as a matter of perspective) a crucial point. Sampling the TCP parameters is fine, but we need to take another reference as well. We need something that says &ldquo;we got the parameters at a certain time or at a certain point&rdquo;. This means we have to measure the time elapsed since the connection started. We could use the number of bytes received, but usually it is better to use the elapsed time. Measuring time in C on various platforms deserves an article on its own; fortunately we are bound to Linux (because we want to use the TCP_INFO option of&nbsp;<tt>getsockopt()</tt>, and this is not portable), and can expect to get time resolution in microseconds. In order to make time management easier, we define two functions:&nbsp;<tt>get_now()</tt>&nbsp;and&nbsp;<tt>time_to_seconds()</tt>.</p>
<pre>/* Get current time. */
void get_now( struct timeval *time, unsigned short debug ) {
if ( gettimeofday( time, NULL ) != 0 ) {
	fprintf(stderr,"Can't get current time.\n");
}
return;
}

/* Convert "struct timeval" to fractional seconds. */
double time_to_seconds ( struct timeval *tstart, struct timeval *tfinish ) {
double t;

t = (tfinish-&gt;tv_sec - tstart-&gt;tv_sec) + (tfinish-&gt;tv_usec - tstart-&gt;tv_usec) / 1e6;
return t;
}</pre>
<p><tt>get_now()</tt>&nbsp;is our stopwatch button, and retrieves the current time by calling&nbsp;<tt>gettimeofday()</tt>&nbsp;and storing it into a memory structure. The second function&nbsp;<tt>time_to_seconds()</tt>&nbsp;calculates the difference of two time value structures, and converts it into fractional seconds. We have to do that ourselves, since the GNU C Library doesn&rsquo;t provide any functions to do fancy date and time calculations. Other libraries could help us out, but I&rsquo;d like to stick to basic methods and basic tools. We have other things to do in our code than to worry about fancy functions. You may have noticed the slightly unused function parameter&nbsp;<tt>debug</tt>in&nbsp;<tt>get_now()</tt>. I&rsquo;ll explain later what it is for (it&rsquo;s a feature, not a bug).</p>
<p>Now, we start our main loop. We take the time, read the stream buffer by buffer, query the socket and write the parameters to a file. Here&rsquo;s the code.</p>
<pre>get_now( &amp;time_start, opt_debug );
while ( (recv_bytes = recv( tcp_work_socket, tcp_buffer, opt_buffer, 0 ) ) &gt; 0 ) {
/* Measure time in order to create time intervals. */
get_now( &amp;time_now, opt_debug );
/* Fill tcp_info structure with data */
tcp_info_length = sizeof(tcp_info);
if ( getsockopt( tcp_work_socket, SOL_TCP, TCP_INFO, (void *)&amp;tcp_info, &amp;tcp_info_length ) == 0 ) {
	fprintf(statistics,"%.6f %u %u %u %u %u %u %u %u %u %u %u %u\n",
			time_to_seconds( &amp;time_start, &amp;time_now ),
			tcp_info.tcpi_last_data_sent,
			tcp_info.tcpi_last_data_recv,
			tcp_info.tcpi_snd_cwnd,
			tcp_info.tcpi_snd_ssthresh,
			tcp_info.tcpi_rcv_ssthresh,
			tcp_info.tcpi_rtt,
			tcp_info.tcpi_rttvar,
			tcp_info.tcpi_unacked,
			tcp_info.tcpi_sacked,
			tcp_info.tcpi_lost,
			tcp_info.tcpi_retrans,
			tcp_info.tcpi_fackets
		   );
	if ( fflush(statistics) != 0 ) {
		fprintf(stderr, "Cannot flush buffers: %s\n", strerror(errno) );
	}
}
}
close(tcp_work_socket);</pre>
<p>First, we take the time to mark the start of the transmission. It gets stored in&nbsp;<tt>time_start</tt>, which we use later for calculating relative time. The&nbsp;<tt>while</tt>&nbsp;loop is our main loop. We call&nbsp;<tt>recv()</tt>, and fill our buffer<tt>tcp_buffer</tt>&nbsp;with a maximum of&nbsp;<tt>opt_buffer</tt>&nbsp;bytes. After the buffer is full, we take the time again. Finally, we call the function&nbsp;<tt>getsockopt()</tt>&nbsp;and request that a memory region of type&nbsp;<tt>struct tcp_info</tt>&nbsp;be filled with parameter data from the live stream. The function works in a fashion similar to that of&nbsp;<tt>bind()</tt>. You have to have a piece of memory ready, indicate its size, give a request code (such as&nbsp;<tt>TCP_INFO</tt>), and&nbsp;<tt>getsockopt()</tt>&nbsp;will copy everything to the memory region indicated by the supplied pointer. If the function returns success, we can access the values in&nbsp;<tt>tcp_info</tt>. You can look up the content of a&nbsp;<tt>struct tcp_info</tt>&nbsp;structure by viewing&nbsp;<tt>/usr/include/netinet/tcp.h</tt>. For your convenience, I have a copy of the definition right here:</p>
<pre>struct tcp_info
{
u_int8_t	tcpi_state;
u_int8_t	tcpi_ca_state;
u_int8_t	tcpi_retransmits;
u_int8_t	tcpi_probes;
u_int8_t	tcpi_backoff;
u_int8_t	tcpi_options;
u_int8_t	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;

u_int32_t	tcpi_rto;
u_int32_t	tcpi_ato;
u_int32_t	tcpi_snd_mss;
u_int32_t	tcpi_rcv_mss;

u_int32_t	tcpi_unacked;
u_int32_t	tcpi_sacked;
u_int32_t	tcpi_lost;
u_int32_t	tcpi_retrans;
u_int32_t	tcpi_fackets;

/* Times. */
u_int32_t	tcpi_last_data_sent;
u_int32_t	tcpi_last_ack_sent;	/* Not remembered, sorry.  */
u_int32_t	tcpi_last_data_recv;
u_int32_t	tcpi_last_ack_recv;

/* Metrics. */
u_int32_t	tcpi_pmtu;
u_int32_t	tcpi_rcv_ssthresh;
u_int32_t	tcpi_rtt;
u_int32_t	tcpi_rttvar;
u_int32_t	tcpi_snd_ssthresh;
u_int32_t	tcpi_snd_cwnd;
u_int32_t	tcpi_advmss;
u_int32_t	tcpi_reordering;
};</pre>
<p>The first part consists of administrative information such as state, retransmits, keepalive probes, and options. There&rsquo;s more, and I went through the Linux kernel code to discover where the values come from and what they mean. The best documentation you can get is to look at your kernel&rsquo;s source at&nbsp;<tt>/lib/modules/`uname -r`/build/net/ipv4/tcp.c</tt>&nbsp;and see how the&nbsp;<tt>tcp_info</tt>&nbsp;is filled. Look for the<tt>tcp_get_info()</tt>&nbsp;function inside, and look up the definition of&nbsp;<tt>struct tcp_sock</tt>&nbsp;in&nbsp;<tt>/lib/modules/`uname -r`/build/include/net/tcp.h</tt>. Most of the data is copied from this structure. Fortunately, we don&rsquo;t need everything. The main objective is to get the congestion window. If you look at the metrics section, you can see some interesting values.&nbsp;<tt>tcpi_rtt</tt>&nbsp;and&nbsp;<tt>tcpi_rttvar</tt>&nbsp;are the Round Trip Time (RTT), and its smoothed mean deviation maximum measured in microseconds. The values&nbsp;<tt>tcpi_rcv_ssthresh</tt>&nbsp;and&nbsp;<tt>tcpi_snd_ssthresh</tt>&nbsp;are the slow start size threshold for sending and receiving. Both can be changed dynamically during transmission and reception of data, and put limits on the window sizes.&nbsp;<tt>tcpi_snd_cwnd</tt>&nbsp;is the sending congestion window.&nbsp;<tt>tcpi_advmss</tt>&nbsp;is the advertised Maximum Segment Size (MSS).&nbsp;<tt>tcpi_reordering</tt>&nbsp;indicates the amount of reordering. (I didn&rsquo;t quite figure out the units and values used to indicate reordering, but I found that RFC 4737 defines a packet reordering metric; maybe it has something to do with it.)</p>
<p>We have to keep in mind that TCP can be used to transport data bidirectionally. Our TCP sink will only receive data. In this case, we should expect that only a part of the parameters will change. The values we want to extract are written to a file descriptor&nbsp;<tt>statistics</tt>&nbsp;by a call to&nbsp;<tt>fprintf()</tt>. The format string and the list of arguments defines what will be written to the statistics log file. You can select whatever values you want, and have a look at the output when shooting streams at our sink.</p>
<div><a name="pullquote_136_pfeiffer_1"></a>
<table summary="pullquote1" border="2"><tbody><tr><td align="left" bgcolor="#b3c7bf"><sup>Category: Protocols</sup><br><strong>Data transmissions over networks create a wealth of aspects regarding performance and reliability. I am amazed by the efforts the kernel developers put into the code of the Linux TCP state machine.</strong></td>
</tr></tbody></table></div>
<h3>The whole source</h3>
<p>The whole source is a bit longer, since I wanted to build a daemon that listens on a socket, receives data, and adds all extracted statistics to a log file. It marks the start and the end of data connections, so that it is easier to parse the log and plot the results. I also added option parsing, which is better suited for changing port number, filename, and the like. The daemon has an option for the debug level as well: if the debug level is greater than 0, the daemon doesn&rsquo;t fork and prints debug messages to&nbsp;<tt>stdout</tt>&nbsp;and&nbsp;<tt>stderr</tt>&nbsp;in case something goes wrong. You can download the source&nbsp;<a href="http://linuxgazette.net/136/misc/pfeiffer/tcpsnoop.c">tcpsnoop.c</a>, a little header file<a href="http://linuxgazette.net/136/misc/pfeiffer/tcpsnoop.h">tcpsnoop.h</a>&nbsp;and a minimalistic&nbsp;<a href="http://linuxgazette.net/136/misc/pfeiffer/Makefile">Makefile</a>. All you need is the GNU C Compiler and the&nbsp;<tt>make</tt>&nbsp;utility. After you have compiled the code (running&nbsp;<tt>make</tt>&nbsp;in the directory where you save the above files should do the trick), the binary&rsquo;s options are as follows.</p>
<pre>luchs@nightfall:~$ ./tcpsnoop -h
Usage: tcpsnoop [-d] [-D debuglevel] [-f filename] [-h] [-p tcpport] [-b buffersize]
luchs@nightfall:~$</pre>
<p>The presence of&nbsp;<tt>-d</tt>&nbsp;tells the program to enter daemon mode.&nbsp;<tt>-D</tt>&nbsp;sets the debug level. Setting a debug level will automatically disable daemon mode.&nbsp;<tt>-f</tt>&nbsp;lets you define a file to write to.&nbsp;<tt>-p</tt>&nbsp;determines the TCP port (default is 42237, can be changed by editing&nbsp;<tt>tcpsnoop.h</tt>).&nbsp;<tt>-b</tt>&nbsp;sets the size of the buffer (defaults to 1500 bytes). Daemon mode can be exited by sending a signal. My signal handlers could probably look a lot better, but feel free to turn the sample code into a mean and efficient piece of software.</p>
<h3>Test driving</h3>
<p>Now let&rsquo;s see if it works or segfaults. We can test the program by using 127.0.0.1. This is a bit of a boring experience, since we have big bandwidth and minimal RTT. You&rsquo;ll see that the threshold for the receiving window will skyrocket very quickly. Anyway, we need a listener process. We issue the following command on the receiver:</p>
<pre>luchs@receiver:~$ ./tcpsnoop -d -f /tmp/logfile.dat -p 23000 -b 4096</pre>
<p>We listen on port 23000 for incoming connections, and write every 4096 bytes a line with the parameters of the connection to the file&nbsp;<tt>logfile.dat</tt>. Note that&nbsp;<tt>tcpsnoop</tt>&nbsp;always appends data, so you won&rsquo;t overwrite old data.</p>
<p>On the sender&rsquo;s side, you need a simple tool that pipes data to a TCP socket. A combination of&nbsp;<tt>cat</tt>, a suitable file, and&nbsp;<tt>netcat</tt>&nbsp;will do nicely.</p>
<pre>luchs@sender:~$ cat big_file.pdf | nc receiver.example.net -w 5 23000</pre>
<p>A file is piped to&nbsp;<tt>netcat</tt>, which in turn connects to our receiver on port 23000 and delivers the data. The option&nbsp;<tt>-w</tt>&nbsp;sets a timeout for the connection.&nbsp;<tt>netcat</tt>&nbsp;stops reading after 5 seconds. (Remember, TCP is bidirectional, leaving&nbsp;<tt>-w</tt>&nbsp;out would make&nbsp;<tt>netcat</tt>&nbsp;wait longer for data coming from the receiver.) Make sure your disk is faster than your network, or preload the file. We want to look at network performance, not at slow disks. While the stream is running our code writes the parameters of the connection to the log file. The logged data should look similar to this:</p>
<pre># Received connection from 127.0.0.1 (AdvMSS 0, PMTU 0, options (): )
0.000167 0 0 2 2147483647 49304 4000 2000 0 0 0 0 0
0.000256 0 0 2 2147483647 49304 4000 2000 0 0 0 0 0
0.000279 0 0 2 2147483647 49304 4000 2000 0 0 0 0 0
...
0.004697 4 0 2 2147483647 114840 4000 2000 0 0 0 0 0
0.004759 4 0 2 2147483647 180376 4000 2000 0 0 0 0 0
0.004818 4 0 2 2147483647 245912 4000 2000 0 0 0 0 0
0.004862 4 0 2 2147483647 278680 4000 2000 0 0 0 0 0
0.004879 4 0 2 2147483647 311448 4000 2000 0 0 0 0 0
0.004937 4 0 2 2147483647 376984 4000 2000 0 0 0 0 0
0.004982 4 0 2 2147483647 409752 4000 2000 0 0 0 0 0
0.004998 4 0 2 2147483647 442520 4000 2000 0 0 0 0 0
0.005040 4 0 2 2147483647 475288 4000 2000 0 0 0 0 0
0.005106 8 4 2 2147483647 507904 4000 2000 0 0 0 0 0
...
0.010765 12 0 2 2147483647 507904 4000 2000 0 0 0 0 0
# Closed connection from 127.0.0.1.</pre>
<p>As you can see, only the receiving slow start threshold is changing. You can now use any tool you want, in order to display the data in another format. I used&nbsp;<tt>gnuplot</tt>&nbsp;to create two diagrams. Both show the transmission of a 7.5 MB PDF file through a VPN tunnel over a 512 kbit/s line with 20ms latency. Just to see if it makes any difference, I used three congestions algorithms on the sender side (Low Priority, Veno and Westwood+). I did one transfer per algorithm, one without traffic on the link, and one while surfing with my browser on multiple news pages. The graphs are marked with&nbsp;<em>noconcurrent</em>&nbsp;and<em>browserbackground</em>, respectively.<br><img src="http://i.minus.com/jOvaflGaqhixI.png" alt="graph1" width="800" height="566" border="0">&nbsp;<img src="http://i.minus.com/jbuI80eDwbawz3.png" alt="graph2" width="800" height="566" border="0"><br><strong>Caution!</strong>&nbsp;These graphs carry no meaning. They just say that uploading something while a link is utilised takes longer than on a link without any load. They also say that inserting different congestion algorithm modules into the kernel leads to different behaviour. We already knew that. The sole purpose of this data is to test drive the code we just wrote, nothing more, nothing less. So the only valid interpretation is &ldquo;It works!&rdquo; (or &ldquo;It seems to work!&rdquo; if you believe in bugs). Hooray!</p>
<p>You might wish to issue</p>
<pre>echo 1 &gt; /proc/sys/net/ipv4/tcp_no_metrics_save</pre>
<p>on both machines to prevent the kernel from storing metric information between different TCP sessions. This is useful for repeated tests from the same IP addresses.</p>
<h3>Conclusions</h3>
<p>I wrote this article as a follow up to my overview of the different Linux TCP congestions algorithm modules. My only intention was to find out what these algorithms are for and what they do. The outcome was much more than I expected. Data transmissions over networks create a wealth of aspects regarding performance and reliability. I am amazed by the efforts the kernel developers put into the code of the Linux TCP state machine. Few people notice this, when they run their servers and workstations with default values that just work because of all the things that were put into the kernel code. I hope that you have more than enough starting points to read about what I presented. You also have some pre-alpha code to play with. Now that we have a TCP sink, we could code the sender&rsquo;s side as well, and record the real congestion window and the sender&rsquo;s threshold. We will do that, but that&rsquo;s a job for one of the next issues of&nbsp;<em>Linux Gazette</em>.</p>
<h3>Useful links</h3>
<ul><li><a href="http://www.cesnet.cz/doc/techzpravy/2004/bulk/bulk.pdf">&ldquo;Bulk&rdquo; utility for TCP performance debugging (PDF)</a></li>
<li><a href="http://www.linuxhowtos.org/C_C++/socket.htm">C/C++ Sockets Tutorial</a></li>
<li><a href="http://vim.sourceforge.net/scripts/script.php?script_id=213">c.vim : C/C++-IDE</a></li>
<li><a href="http://lxr.linux.no/">Cross-Referencing Linux</a></li>
<li><a href="http://linux-net.osdl.org/index.php/TCP_memory_documentation">TCP memory documentation</a></li>
<li><a href="http://www.enderunix.org/docs/eng/daemon.php">Unix Daemon Server Programming</a></li>
</ul><p>&nbsp;</p>
					</div><!-- .entry-content -->
		
		<footer class="entry-meta">
			This entry was posted in <a href="http://log.SunnyBoy.Me/category/leading/" rel="category tag">Leading</a> on <a href="http://log.SunnyBoy.Me/2012/08/19/13925/" title="8:52 PM" rel="bookmark"><time class="entry-date" datetime="2012-08-19T20:52:11+00:00">2012/08/19</time></a><span class="by-author"> by <span class="author vcard"><a class="url fn n" href="http://log.SunnyBoy.Me/author/ggbingo/" title="View all posts by Sunny" rel="author">Sunny</a></span></span>.								</footer><!-- .entry-meta --></article><!-- #post --><article id="post-13918" class="post-13918 post type-post status-publish format-standard hentry category-default tag-music"><header class="entry-header"><h1 class="entry-title">
				<a href="http://log.SunnyBoy.Me/2012/08/19/13918/" rel="bookmark">&#65351;&#65291; digest &#26356;&#26032; 2012/08/19</a>
			</h1>
										<div class="comments-link">
					<a href="http://log.SunnyBoy.Me/2012/08/19/13918/#respond"><span class="leave-reply">Leave a reply</span></a>				</div><!-- .comments-link -->
					</header><!-- .entry-header --><div class="entry-content">
			<ul class="scrd_digest"><li><a href="https://plus.google.com/112706220355730950411/posts/DqUemeZJodm" rel="external">18.08.2012 12:39</a>
<div>
<div>
<p>
										<a href="http://www.williamlong.info/info/archives/664.html" target="_blank">&#31449;&#38271;&#25925;&#20107;&#65306;&#32593;&#31449;&#22495;&#21517;&#34987;&#30423;&#30340;&#32463;&#21382;-&#32593;&#31449;&#36816;&#33829;&#20248;&#21270;</a>
									</p>
</div>
</div>
</li>
<li><a href="https://plus.google.com/112706220355730950411/posts/bXbtK82A4bG" rel="external">18.08.2012 11:54</a>
<div>
<div>
<p>
										<a href="http://www.williamlong.info/archives/3174.html" target="_blank">&ldquo;&#30000;&#24524;&#36187;&#39532;&rdquo;&#19982;&#33529;&#26524;-&#26376;&#20809;&#21338;&#23458;</a>
									</p>
<p>
										<a href="http://www.williamlong.info/archives/3174.html" target="_blank"><img src="https://images0-focus-opensocial.googleusercontent.com/gadgets/proxy?container=focus&amp;gadget=a&amp;resize_h=100&amp;url=http://www.williamlong.info/upload/3174_2.jpg" height="100"></a>
									</p>
</div>
</div>
</li>
<li><a href="https://plus.google.com/112706220355730950411/posts/UBJbAcPYUmd" rel="external">18.08.2012 11:45</a>
<div>
<div>
<p>
										<a href="http://www.williamlong.info/archives/3178.html" target="_blank">&#35848;&#35848;&#23460;&#20869;&#23450;&#20301;&#25216;&#26415;</a>
									</p>
</div>
</div>
</li>
<li><a href="https://plus.google.com/112706220355730950411/posts/gwMzhYgaVJr" rel="external">18.08.2012 11:09</a>
<div>
<div>
<p>
										<a href="http://songshuhui.net/archives/71726" target="_blank">&#31185;&#23398;&#26494;&#40736;&#20250; &raquo; &#20026;&#20160;&#20040;&#35784;&#39575;&#30701;&#20449;&#30475;&#19978;&#21435;&#37027;&#20040;&#24369;&#26234;&#65311;</a>
									</p>
<p>
										<a href="http://songshuhui.net/archives/71726" target="_blank"><img src="https://images0-focus-opensocial.googleusercontent.com/gadgets/proxy?container=focus&amp;gadget=a&amp;resize_h=100&amp;url=http://songshuhui.net/wp-content/uploads/2012/08/nzrnxd.png" height="100"></a>
									</p>
</div>
</div>
</li>
<li><a href="https://plus.google.com/112706220355730950411/posts/ZDyYW7xGT76" rel="external">18.08.2012 10:30</a>
<div>
<div>
<p>
										<a href="http://jandan.net/2012/07/11/light-fast-baseball.html" target="_blank">0.9&#20493;&#20809;&#36895;&#30340;&#26834;&#29699;&#20002;&#20986;&#21435;&#65292;&#20250;&#21457;&#29983;&#20160;&#20040;&#65311;</a>
									</p>
<p>
										<a href="http://jandan.net/2012/07/11/light-fast-baseball.html" target="_blank"><img src="https://images0-focus-opensocial.googleusercontent.com/gadgets/proxy?container=focus&amp;gadget=a&amp;resize_h=100&amp;url=http://tankr.net/s/medium/DDQ8.png" height="100"></a>
									</p>
</div>
</div>
</li>
</ul><p class="scrd_credit">Digest powered by <a href="http://www.rssdigestpro.com">RSS Digest</a></p>
					</div><!-- .entry-content -->
		
		<footer class="entry-meta">
			This entry was posted in <a href="http://log.SunnyBoy.Me/category/default/" rel="category tag">Default</a> and tagged <a href="http://log.SunnyBoy.Me/tag/music/" rel="tag">Music</a> on <a href="http://log.SunnyBoy.Me/2012/08/19/13918/" title="6:01 AM" rel="bookmark"><time class="entry-date" datetime="2012-08-19T06:01:18+00:00">2012/08/19</time></a><span class="by-author"> by <span class="author vcard"><a class="url fn n" href="http://log.SunnyBoy.Me/author/sunny/" title="View all posts by Sunny" rel="author">Sunny</a></span></span>.								</footer><!-- .entry-meta --></article><!-- #post --></div><!-- #content -->
	</section><!-- #primary --><div id="secondary" class="widget-area" role="complementary">
			<aside id="calendar-3" class="widget widget_calendar"><h3 class="widget-title">Posts Calendar</h3><div id="calendar_wrap" class="calendar_wrap"><table id="wp-calendar"><caption>August 2012</caption>
	<thead><tr><th scope="col" title="Monday">M</th>
		<th scope="col" title="Tuesday">T</th>
		<th scope="col" title="Wednesday">W</th>
		<th scope="col" title="Thursday">T</th>
		<th scope="col" title="Friday">F</th>
		<th scope="col" title="Saturday">S</th>
		<th scope="col" title="Sunday">S</th>
	</tr></thead><tfoot><tr><td colspan="3" id="prev"><a href="http://log.SunnyBoy.Me/2012/07/">&laquo; Jul</a></td>
		<td class="pad">&nbsp;</td>
		<td colspan="3" id="next"><a href="http://log.SunnyBoy.Me/2012/09/">Sep &raquo;</a></td>
	</tr></tfoot><tbody><tr><td colspan="2" class="pad">&nbsp;</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
	</tr><tr><td>6</td><td><a href="http://log.SunnyBoy.Me/2012/08/07/" aria-label="Posts published on August 7, 2012">7</a></td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td>
	</tr><tr><td>13</td><td><a href="http://log.SunnyBoy.Me/2012/08/14/" aria-label="Posts published on August 14, 2012">14</a></td><td><a href="http://log.SunnyBoy.Me/2012/08/15/" aria-label="Posts published on August 15, 2012">15</a></td><td><a href="http://log.SunnyBoy.Me/2012/08/16/" aria-label="Posts published on August 16, 2012">16</a></td><td>17</td><td>18</td><td><a href="http://log.SunnyBoy.Me/2012/08/19/" aria-label="Posts published on August 19, 2012">19</a></td>
	</tr><tr><td><a href="http://log.SunnyBoy.Me/2012/08/20/" aria-label="Posts published on August 20, 2012">20</a></td><td><a href="http://log.SunnyBoy.Me/2012/08/21/" aria-label="Posts published on August 21, 2012">21</a></td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td>
	</tr><tr><td><a href="http://log.SunnyBoy.Me/2012/08/27/" aria-label="Posts published on August 27, 2012">27</a></td><td>28</td><td>29</td><td>30</td><td><a href="http://log.SunnyBoy.Me/2012/08/31/" aria-label="Posts published on August 31, 2012">31</a></td>
		<td class="pad" colspan="2">&nbsp;</td>
	</tr></tbody></table></div></aside><aside id="categories-3" class="widget widget_categories"><h3 class="widget-title">Categories</h3>		<ul><li class="cat-item cat-item-3"><a href="http://log.SunnyBoy.Me/category/default/">Default</a> (75)
</li>
	<li class="cat-item cat-item-4"><a href="http://log.SunnyBoy.Me/category/english/">English</a> (1)
</li>
	<li class="cat-item cat-item-5"><a href="http://log.SunnyBoy.Me/category/for-the-music/">For The Music !</a> (55)
</li>
	<li class="cat-item cat-item-27"><a href="http://log.SunnyBoy.Me/category/jobb/">Jobb</a> (6)
</li>
	<li class="cat-item cat-item-9"><a href="http://log.SunnyBoy.Me/category/languages/">Languages</a> (5)
</li>
	<li class="cat-item cat-item-7"><a href="http://log.SunnyBoy.Me/category/leading/">Leading</a> (36)
</li>
	<li class="cat-item cat-item-83"><a href="http://log.SunnyBoy.Me/category/life/">Life</a> (134)
</li>
	<li class="cat-item cat-item-72"><a href="http://log.SunnyBoy.Me/category/matlab/">Matlab</a> (1)
</li>
	<li class="cat-item cat-item-77"><a href="http://log.SunnyBoy.Me/category/nix/">nix</a> (5)
</li>
	<li class="cat-item cat-item-1"><a href="http://log.SunnyBoy.Me/category/others/">Others</a> (719)
</li>
	<li class="cat-item cat-item-31"><a href="http://log.SunnyBoy.Me/category/php/">Php</a> (3)
</li>
	<li class="cat-item cat-item-82"><a href="http://log.SunnyBoy.Me/category/pol/">POL</a> (9)
</li>
	<li class="cat-item cat-item-86"><a href="http://log.SunnyBoy.Me/category/py/">py</a> (1)
</li>
	<li class="cat-item cat-item-76"><a href="http://log.SunnyBoy.Me/category/seo/">seo</a> (1)
</li>
	<li class="cat-item cat-item-62"><a href="http://log.SunnyBoy.Me/category/softskills/">Soft&amp;Skills</a> (47)
</li>
	<li class="cat-item cat-item-8"><a href="http://log.SunnyBoy.Me/category/stefanie/">Stefanie</a> (195)
</li>
	<li class="cat-item cat-item-11"><a href="http://log.SunnyBoy.Me/category/svenska/">Svenska</a> (25)
</li>
	<li class="cat-item cat-item-73"><a href="http://log.SunnyBoy.Me/category/sverige/">Sverige</a> (3)
</li>
	<li class="cat-item cat-item-12"><a href="http://log.SunnyBoy.Me/category/swe/">SWE</a> (2)
</li>
	<li class="cat-item cat-item-74"><a href="http://log.SunnyBoy.Me/category/cssdiv/">web</a> (5)
</li>
		</ul></aside><aside id="linkcat-2" class="widget widget_links"><h3 class="widget-title">Suggest Link</h3>
	<ul class="xoxo blogroll"><li><a href="http://blog.zhaoqi.org" rel="friend" title="A blog of my best friend." target="_blank">Q's Blog</a>
A blog of my best friend.</li>
<li><a href="http://db.tt/GlIsWkt" title="Use this link to get 250M bonus  ~ " target="_blank">Recommended Soft: DropBox</a>
Use this link to get 250M bonus  ~ </li>
<li><a href="http://feedburner.google.com/fb/a/mailverify?uri=SunnyRSS&amp;loc=en_US">Subscribe My Blog by Email</a></li>
<li><a href="http://log.SunnyBoy.Me/feed/">Subscribe My Blog by RSS</a></li>

	</ul></aside></div><!-- #secondary -->
		</div><!-- #main .wrapper -->
	<footer id="colophon" role="contentinfo"><div class="site-info">
						<a href="https://wordpress.org/" title="Semantic Personal Publishing Platform">Proudly powered by WordPress</a>
		</div><!-- .site-info -->
	</footer><!-- #colophon --></div><!-- #page -->

<script type="text/javascript" src="http://log.SunnyBoy.Me/wp-content/themes/twentytwelve/js/navigation.js?ver=20140711"></script><script type="text/javascript" src="http://log.SunnyBoy.Me/wp-includes/js/wp-embed.min.js?ver=4.5.1"></script></body></html>
